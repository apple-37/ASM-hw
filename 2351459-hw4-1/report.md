# 4：乘法指令和过程调用（一）输出九九乘法表

**姓名**：[滕其峰]

**学号**：[2351459]

**日期**：2025/12/7

---

## 一、 实验背景与目的

1.  **掌握乘法指令**：熟练使用 `MUL` 指令进行无符号数乘法运算，理解其隐含操作数（AL/AX）及结果存放位置。
2.  **掌握子程序设计**：理解过程调用（`CALL`）和返回（`RET`）指令的执行机制，掌握子程序中寄存器的保护与恢复（堆栈操作）。
3.  **熟练运用循环控制**：复习双重循环的实现方法，特别是外层循环计数器在内层循环中的保存与恢复。
4.  **理解高级语言底层实现**：通过 C 语言代码与反汇编代码的对比，理解全局变量与局部变量在内存存储及访问方式上的差异。

## 二、 实验内容

编写汇编程序，在屏幕上输出倒三角形格式的九九乘法表（即第一行从 9\*1 到 9\*9，最后一行是 1\*1），并满足以下要求：

1.  至少实现一个过程调用（如数字打印功能）。
2.  在过程中正确处理主过程的寄存器资源保护。
3.  使用 C 语言编写类似逻辑，并查看反汇编代码进行对比分析。

## 三、 实验原理与代码逻辑

### 1. 算法流程设计

为了输出截图所示的“倒三角”乘法表，逻辑如下：

- **外循环 (Row)**：控制乘数 1（行号）。使用 `CX` 寄存器，初始值为 9，每次循环减 1，直到 1。利用 `LOOP` 指令实现。
- **内循环 (Col)**：控制乘数 2（列号）。使用 `BX` 寄存器，初始值为 1，每次递增，直到 `BX > CX` 停止。
- **计算**：`Result = Row * Col`。
- **显示**：调用子程序 `PRINT_NUM` 将二进制数值转换为十进制 ASCII 码显示。

### 2. 关键汇编指令分析

- **乘法**：`MUL BL`。该指令隐含操作数为 `AL`（存放 Row），结果存放在 `AX` 中。
- **堆栈保护**：
  - **循环保护**：外层循环使用 `CX` 计数，但内层逻辑或子程序可能会影响 `CX`，因此进入外层循环体时需执行 `PUSH CX`，循环结束前 `POP CX`。
  - **子程序保护**：`PRINT_NUM` 子程序内部使用了 `AX`, `BX`, `DX`，为了不影响主程序逻辑，在子程序开头 `PUSH` 这些寄存器，返回前 `POP`。

### 3. 汇编源代码实现

```assembly
DATA SEGMENT
    NEWLINE  DB 0DH, 0AH, '$' ; 回车换行
    SPACE    DB '  ', '$'     ; 间隔符
    EQ_SIGN  DB '=', '$'      ; 等号
    MUL_SIGN DB '*', '$'      ; 乘号
DATA ENDS

CODE SEGMENT
    ASSUME CS:CODE, DS:DATA
START:
    MOV AX, DATA
    MOV DS, AX

    ; --- 主程序逻辑 ---
    MOV CX, 9       ; 外循环初始化：从9开始倒序

OUTER_LOOP:
    PUSH CX         ; 【关键】保存外层循环计数器，因为LOOP指令依赖CX

    MOV BX, 1       ; 内循环初始化：从1开始

INNER_LOOP:
    ; 1. 打印表达式 "CX * BX ="
    MOV AX, CX
    CALL PRINT_NUM  ; 打印被乘数

    MOV AH, 09H
    LEA DX, MUL_SIGN
    INT 21H

    MOV AX, BX
    CALL PRINT_NUM  ; 打印乘数

    MOV AH, 09H
    LEA DX, EQ_SIGN
    INT 21H

    ; 2. 计算乘积
    MOV AX, CX      ; AX = Row
    MUL BL          ; AX = AL * BL (乘积)

    ; 3. 打印结果
    CALL PRINT_NUM

    ; 4. 打印空格
    MOV AH, 09H
    LEA DX, SPACE
    INT 21H

    ; 5. 内循环控制
    INC BX          ; 列号++
    CMP BX, CX      ; 比较当前列号与行号
    JLE INNER_LOOP  ; 若 列 <= 行，继续循环

    ; --- 换行处理 ---
    MOV AH, 09H
    LEA DX, NEWLINE
    INT 21H

    POP CX          ; 【关键】恢复外层循环计数器
    LOOP OUTER_LOOP ; CX--, 若CX!=0则跳转

    ; 退出程序
    MOV AH, 4CH
    INT 21H

; --------------------------------------------------
; 子过程：PRINT_NUM
; 功能：将AX中的数值(0-99)以十进制打印
; --------------------------------------------------
PRINT_NUM PROC NEAR
    PUSH AX         ; 保存现场
    PUSH BX
    PUSH DX

    MOV BL, 10
    DIV BL          ; AX / 10 -> AL=商(十位), AH=余数(个位)

    MOV BX, AX      ; 暂存结果

    CMP BL, 0       ; 检查十位是否为0
    JE SKIP_TENS    ; 若为0则不打印十位

    MOV DL, BL
    ADD DL, 30H     ; 转ASCII
    MOV AH, 02H
    INT 21H

SKIP_TENS:
    MOV DL, BH      ; 处理个位
    ADD DL, 30H
    MOV AH, 02H
    INT 21H

    POP DX          ; 恢复现场
    POP BX
    POP AX
    RET
PRINT_NUM ENDP

CODE ENDS
    END START
```

## 四、 实验结果

程序编译链接后运行，屏幕输出如下（与题目要求一致）：

```text
9*1=9   9*2=18  9*3=27  ...  9*9=81
8*1=8   8*2=16  ... 8*8=64
...
2*1=2   2*2=4
1*1=1
```

## 五、 C 语言与汇编对比分析

根据实验要求，使用 C 语言编写了对照代码，并利用反汇编工具观察变量存储的区别。

### 1. 变量定义的区别

- **全局变量 (`global_row`)**：

  - **C 代码**：定义在 `main` 函数外。
  - **汇编表现**：`mov eax, DWORD PTR global_row[rip]`。
  - **分析**：全局变量存储在数据段（Data Segment），在汇编中通常使用绝对地址或 RIP 相对寻址直接访问。这与我们在汇编代码 `DATA SEGMENT` 中定义变量的方式一致。

- **局部变量 (`i`, `j`, `result`)**：
  - **C 代码**：定义在 `main` 函数内的循环中。
  - **汇编表现**：`mov DWORD PTR [rbp-4], eax` 或 `[rbp-8]`。
  - **分析**：局部变量存储在**栈（Stack）**中。编译器通过 `rbp`（栈基址指针）减去偏移量来定位这些变量。这解释了为什么在汇编子程序中我们要手动管理堆栈——高级语言编译器自动帮我们完成了这些繁琐的工作。

### 2. 运算逻辑

- C 语言中的 `i * j` 一行代码，对应到底层汇编即为加载内存变量到寄存器 -> 执行 `imul` -> 将结果写回栈内存的过程。

## 六、 实验总结与体会

1.  **寄存器资源管理**：本次实验最深刻的体会是“保护现场”。在使用 `LOOP` 指令时，如果不将外层循环的 `CX` 压栈，内层循环或子程序一旦修改了 `CX`，程序就会陷入死循环或逻辑错误。这是汇编语言与高级语言最大的不同点之一。
2.  **过程调用的模块化**：通过编写 `PRINT_NUM` 子程序，主程序的逻辑变得非常清晰。这验证了将重复功能封装为过程（Procedure）的必要性。
3.  **DIV 指令的细节**：在使用 `DIV` 做除法获取十进制位时，必须注意被除数是 16 位的 `AX`，商在 `AL`，余数在 `AH`。如果混淆了寄存器的高低位，打印出的数字就会出错。
4.  **底层视野**：通过对比 C 语言反汇编，我明白了为什么局部变量生命周期仅限于函数内（因为它们随栈帧销毁），而全局变量贯穿程序始终。

---
