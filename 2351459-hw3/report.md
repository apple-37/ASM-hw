# 3：求和（循环结构与数制转换）

**姓名**：[滕其峰]

**学号**：[2351459]

**日期**：2025/12/7

---

## 一、 实验背景与目的

1.  **掌握循环结构**：熟练使用 `LOOP` 指令或条件跳转指令（`JNZ` 等）实现累加求和逻辑。
2.  **理解数据的存储与表示**：深入理解计算机内部数值（二进制/十六进制）与人机交互界面（ASCII 码/十进制）之间的区别与转换方法。
3.  **掌握 DOS 系统调用**：学习使用 `INT 21H` 的 02H（字符输出）、09H（字符串输出）和 0Ah（缓冲输入）功能。
4.  **理解子程序设计**：掌握过程调用（`CALL` / `RET`）及堆栈在保存现场和参数传递中的应用。
5.  **高级语言对比**：通过对比 C 语言反汇编代码，理解高级语言变量存储（全局 vs 局部）与底层汇编指令的对应关系。

## 二、 实验内容

### 任务 1：计算 1+2+...+100 并显示

编写汇编程序，计算 $1+2+...+100$ 的结果（5050），并将该结果以十进制形式打印在屏幕上。

### 任务 2：交互式求和

程序接收用户输入的数字 N（1~100），计算 $1+2+...+N$ 的结果并输出。

### 任务 3：C 语言实现与反汇编分析

用 C 语言实现上述逻辑，并观察反汇编代码，分析变量存储位置的区别。

---

## 三、 实验原理与代码实现

### 1. 核心算法：累加求和

在汇编中，使用 `AX` 寄存器作为累加器，`CX` 作为循环计数器。

```assembly
    MOV AX, 0       ; 初始化和为 0
    MOV CX, 100     ; 循环 100 次
SUM_LOOP:
    ADD AX, CX      ; AX = AX + CX
    LOOP SUM_LOOP   ; CX--, 若 CX!=0 跳转
```

循环结束后，`AX` 中存储的是 `0x13BA`（十六进制），即十进制的 `5050`。

### 2. 核心难点：数值到字符串的转换（Binary to ASCII）

由于屏幕输出（`INT 21H`）只能接受 ASCII 字符，我们需要将 `0x13BA` 转换为字符串 "5050"。

- **原理**：反复除以 10 取余法。
- **步骤**：
  1.  `5050 / 10` -> 商 `505`，余数 `0` -> 压栈
  2.  `505 / 10` -> 商 `50`，余数 `5` -> 压栈
  3.  `50 / 10` -> 商 `5`，余数 `0` -> 压栈
  4.  `5 / 10` -> 商 `0`，余数 `5` -> 压栈
  5.  循环结束。
  6.  **出栈**并打印：利用堆栈“先进后出”的特性，依次弹出 `5`, `0`, `5`, `0`，加上 `'0'` (0x30) 转换为 ASCII 码输出。

### 3. 代码实现（Task 1: 1-100 求和）

```assembly
; 核心子程序：PRINT_DEC
; 功能：将 AX 中的数值以十进制打印
PRINT_DEC PROC
    PUSH AX
    PUSH BX
    PUSH CX
    PUSH DX

    MOV CX, 0           ; 计数器清零
CONVERT_LOOP:
    MOV DX, 0           ; 16位除法高位清零
    MOV BX, 10
    DIV BX              ; AX / 10 -> 商在AX, 余数在DX
    ADD DL, '0'         ; 转 ASCII
    PUSH DX             ; 余数入栈
    INC CX              ; 位数+1
    CMP AX, 0           ; 商为0了吗？
    JNE CONVERT_LOOP

PRINT_LOOP:
    POP DX              ; 逆序弹出
    MOV AH, 02H         ; DOS 打印字符
    INT 21H
    LOOP PRINT_LOOP

    POP DX              ; 恢复寄存器
    POP CX
    POP BX
    POP AX
    RET
PRINT_DEC ENDP
```

### 4. 代码实现（Task 2: 用户输入求和）

**输入处理难点**：
DOS 的 0Ah 功能调用需要定义一个缓冲区结构：
`BUFFER DB 4, 0, 4 DUP('$')`

- 第 1 字节：最大允许字符数。
- 第 2 字节：实际输入字符数（系统自动回填）。
- 后续字节：存储输入的字符串（如 "100"）。

**字符串转数值逻辑**：
我们需要将字符串 "100" 转换为数字 100 存入寄存器。

- 算法：`Result = Result * 10 + (CurrentChar - '0')`
- 遍历输入缓冲区的每一个字符，执行上述公式。

---

## 四、 实验结果与分析

### 2. 结果数据存放位置的探讨

题目要求尝试将结果放在不同位置，分析如下：

1.  **放在寄存器中 (`AX`)**：

    - **优点**：访问速度最快，指令最短（如 `ADD AX, CX`）。
    - **缺点**：寄存器数量有限，用于临时计算，无法长期保存。
    - **本实验做法**：我们在计算过程中一直使用寄存器，直到打印前才处理。

2.  **放在数据段中 (`DATA SEGMENT`)**：

    - **做法**：定义变量 `RESULT DW ?`，计算后 `MOV RESULT, AX`。
    - **优点**：数据持久化，整个程序生命周期内有效，方便调试查看内存。
    - **反汇编视角**：C 语言的**全局变量**即存储于此。

3.  **放在栈中 (`STACK`)**：
    - **做法**：`PUSH AX` 保存结果。
    - **优点**：用于保护现场或函数间传递参数。
    - **反汇编视角**：C 语言的**局部变量**存储于栈帧（Stack Frame）中。

---

## 五、 C 语言反汇编对比分析

为了深入理解底层实现，编写了如下 C 语言代码并查看其反汇编（Intel 语法）。

### 1. C 语言源码

```c
#include <stdio.h>

// 全局变量 -> 存放在数据段
int global_sum = 0;

int main() {
    // 局部变量 -> 存放在栈 (Stack) 中
    int n = 100;
    int local_sum = 0;
    int i;

    for (i = 1; i <= n; i++) {
        local_sum += i;
    }

    printf("Sum: %d", local_sum);
    return 0;
}
```

### 2. 反汇编代码分析 (x86-64 示例)

**A. 局部变量的初始化 (栈操作)**

```assembly
push   rbp
mov    rbp, rsp
mov    DWORD PTR [rbp-4], 100   ; 变量 n 存储在栈 [rbp-4]
mov    DWORD PTR [rbp-8], 0     ; 变量 local_sum 存储在栈 [rbp-8]
mov    DWORD PTR [rbp-12], 1    ; 变量 i 存储在栈 [rbp-12]
```

_分析_：可以看到 C 语言的局部变量并不像汇编作业那样直接使用 `AX` 或 `CX` 长期存放，而是频繁地读写内存栈空间（`[rbp-xx]`）。这是为了保证函数递归调用时的安全性。

**B. 循环累加过程**

```assembly
.L3:
mov    eax, DWORD PTR [rbp-12]  ; 从栈取出 i 放入 EAX
cmp    eax, DWORD PTR [rbp-4]   ; 比较 i 和 n
jg     .L4                      ; 如果 i > n，跳出循环

mov    eax, DWORD PTR [rbp-12]  ; 取出 i
add    DWORD PTR [rbp-8], eax   ; local_sum += i (直接修改栈内存)
add    DWORD PTR [rbp-12], 1    ; i++
jmp    .L3
```

_分析_：

1.  **效率对比**：手写的汇编代码（使用 `LOOP` 和寄存器）通常比未优化的 C 语言反汇编代码（频繁读写内存）要高效。
2.  **逻辑一致性**：`ADD`、`CMP`、`JMP` 这些基础指令在两种语言中是一致的。

## 六、 实验总结

通过本次实验，我完成了从“静态计算”到“动态交互”的汇编程序设计。

1.  **进位制转换**：深刻理解了计算机内部“二进制计算”与外部“十进制显示”的分离。`5050` 在内存中只是 `13BAh`，必须通过除法运算转换为字符序列才能被人类阅读。
2.  **堆栈的妙用**：在数制转换中，利用堆栈 `FILO` 的特性，巧妙解决了“计算生成是低位到高位，打印需求是高位到低位”的矛盾。
3.  **系统调用**：掌握了 `INT 21H` 处理字符串输入的缓冲区机制，这对后续开发交互式程序至关重要。
4.  **软硬结合**：通过对比 C 语言，明白了高级语言变量定义的底层物理位置（数据段 vs 栈），建立了代码与内存的映射观念。

---
