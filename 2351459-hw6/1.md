# 课程实验报告：重写溢出中断服务程序

**姓名**：[滕其峰]

**学号**：[2351459]

**日期**：2025/12/7

---

## 一、实验背景与目的

1. **理解标志寄存器（FLAGS）**：掌握 CPU 中进位标志（CF，无符号）与溢出标志（OF，有符号）的区别和作用。
2. **掌握溢出检测原理**：理解有符号数运算溢出时 OF 标志的变化，体会硬件层面对运算错误的检测。
3. **C 语言与硬件行为的差异**：C 语言对有符号溢出为未定义行为，程序不会自动报错。本实验通过汇编和中断机制捕捉溢出。
4. **掌握中断服务程序（ISR）编写**：学习如何重写 INTO（4 号中断）的服务程序，理解中断向量表的修改与恢复。

## 二、实验环境

- 操作系统：MS-DOS 或 DOSBox
- 开发工具：MASM/TASM 汇编器，Turbo C 2.0/Borland C++（支持 16 位内联汇编）
- 硬件架构：x86 16 位实模式

## 三、实验原理

### 1. 溢出标志（OF）

有符号数加法时，若结果超出表示范围（如 8 位：-128~127，16 位：-32768~32767），OF 会被置 1。

### 2. INTO 指令与 4 号中断

INTO（Interrupt on Overflow）指令在 OF=1 时自动触发 4 号中断（INT 4），否则无操作。该机制可用于捕捉有符号溢出异常。

### 3. 中断向量表

中断向量表存储各中断类型的服务程序入口地址。默认 4 号中断服务程序内容为空（仅 IRET）。本实验需将其重定向到自定义 ISR，并在实验结束后恢复。

## 四、实验内容与实现

### 1. 汇编实现（int0.asm）

1. 保存原 INT0（4 号中断）向量。
2. 编写新的 INT0 服务程序，显示溢出信息并计数。
3. 安装新服务程序到中断向量表。
4. 制造溢出（如 AL=120, ADD 50, INTO），观察 ISR 响应。
5. 恢复原中断向量。

**关键代码片段：**

```asm
new_int0_handler PROC FAR
    ; ...现场保护...
    INC overflow_count
    MOV AH, 09h
    MOV DX, OFFSET overflow_msg
    INT 21h
    ; ...显示溢出次数...
    IRET
new_int0_handler ENDP

MAIN PROC
    ; 保存原向量
    MOV AX, 3504h
    INT 21h
    MOV old_int0_seg, ES
    MOV old_int0_off, BX
    ; 安装新ISR
    MOV AX, 2504h
    MOV DX, OFFSET new_int0_handler
    MOV CX, SEG new_int0_handler
    PUSH DS
    MOV DS, CX
    INT 21h
    POP DS
    ; ...测试溢出...
    ; 恢复原ISR
    MOV AX, 2504h
    MOV DX, old_int0_off
    MOV CX, old_int0_seg
    PUSH DS
    MOV DS, CX
    INT 21h
    POP DS
    ; 结束
    MOV AH, 4Ch
    INT 21h
MAIN ENDP
```

### 2. C 语言内联汇编溢出检测（overflow.c）

1. 通过内联汇编制造溢出（如 signed char/short 加法）。
2. 检查溢出标志，模拟 INT0 处理。
3. 统计溢出次数，输出提示信息。

**关键代码片段：**

```c
// 检测溢出并模拟INT0处理
asm volatile (
    "movb %2, %%al\n"
    "addb %3, %%al\n"
    "seto %b1\n"
    "movb %%al, %0\n"
    : "=m" (overflow_result), "=q" (overflow_detected)
    : "m" (max_val), "m" (add_val)
    : "al", "cc"
);
if (overflow_detected) {
    printf("检测到溢出! 模拟INT0中断处理...\n");
    overflow_count++;
    printf("%s", overflow_msg);
}
```

## 五、实验结果

### 1. 汇编程序运行结果

程序自动制造多次溢出，屏幕显示溢出提示及累计次数，证明 ISR 被正确调用。

### 2. C 程序运行结果

多组有符号加法，溢出时检测到并输出“Overflow detected! Interrupt 0 handled.”，溢出次数统计正确。

**结果分析：**

1. 溢出时，OF=1，INTO 或 seto 均能检测并响应。
2. 汇编 ISR 可直接处理异常，C 语言需借助内联汇编和标志位判断。
3. 中断服务程序的安装与恢复保证了系统稳定。

## 六、实验总结与体会

1. **中断机制的优势**：通过硬件中断可高效捕捉和处理异常，避免繁琐的条件判断。
2. **ISR 编写要点**：需现场保护、正确恢复原向量，避免系统异常。
3. **C 与汇编协作**：C 语言可通过内联汇编访问底层标志位，实现更精细的错误检测。
4. **实验收获**：本实验加深了对 CPU 标志寄存器、中断机制、溢出检测原理的理解，提升了底层编程能力。

---
