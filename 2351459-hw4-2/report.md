# 4：乘法指令和过程调用（九九乘法表纠错）

**姓名**：[滕其峰]

**学号**：[2351459]

**日期**：2025/12/7

---

## 一、 实验背景与目的

1.  **掌握乘法指令**：熟悉 `MUL` 指令的使用，特别是 8 位乘法（`AL * Reg/Mem -> AX`）的操作。
2.  **掌握过程调用**：理解 `CALL` 和 `RET` 指令的执行流程，掌握在子过程中保存和恢复主程序寄存器资源的方法（堆栈操作）。
3.  **复习双重循环**：在汇编语言中实现嵌套循环（行与列的遍历）。
4.  **C 语言与汇编的映射**：通过 C 语言实现并在反汇编中观察全局变量与局部变量在内存存储和访问方式上的区别。

## 二、 实验内容与要求

**任务**：检查内存中预置的一张 9\*9 乘法表数据。

1.  **数据源**：程序数据段中定义了一组数据，其中部分位置的人为设置了错误值（如图所示，错误数据均为 `7`）。
2.  **逻辑处理**：编写汇编程序，通过双重循环遍历 1~9 行和 1~9 列，计算理论值（Row \* Col）并与内存中的实际值进行比较。
3.  **输出要求**：如果发现数据不一致，调用子过程在屏幕上打印错误的坐标（行号、列号）及提示信息 "error"。
4.  **对比分析**：用 C 语言实现相同逻辑，并对比分析全局数组与局部数组在汇编层面的区别。

## 三、 实验原理与代码实现（汇编部分）

### 1. 数据结构分析

数据段定义了一个线性数组 `TABLE`，按行存储 9x9 乘法表的所有结果（共 81 个字节）。

- **寻址方式**：使用寄存器相对寻址或基址变址寻址。在本例中使用 `SI` 作为线性索引（0~80），`TABLE[SI]` 获取数据。

### 2. 核心算法流程

- **外循环 (Row)**：`CX` 从 1 到 9。
- **内循环 (Col)**：`BX` 从 1 到 9。
- **计算理论值**：`MOV AX, CX` -> `MUL BL`。此时 `AL` 中存储的是正确的乘积。
- **比较**：`CMP AL, TABLE[SI]`。
- **报错**：若不相等，执行 `CALL PRINT_ERROR_MSG`。

### 3. 汇编源代码

```assembly
DATA SEGMENT
    ; 预置的 9x9 乘法表数据，包含人为植入的错误（红色标记处）
    TABLE DB 7, 2, 3, 4, 5, 6, 7, 8, 9          ; Row 1 (1*1=1, 这里是7, ERROR)
          DB 2, 4, 7, 8, 10, 12, 14, 16, 18     ; Row 2 (2*3=6, 这里是7, ERROR)
          DB 3, 6, 9, 12, 15, 18, 21, 24, 27    ; Row 3
          DB 4, 8, 12, 16, 7, 24, 28, 32, 36    ; Row 4 (4*4=16, 这里是7, ERROR)
          DB 5, 10, 15, 20, 25, 30, 35, 40, 45  ; Row 5
          DB 6, 12, 18, 24, 30, 7, 42, 48, 54   ; Row 6 (6*5=30, 这里是7, ERROR)
          DB 7, 14, 21, 28, 35, 42, 49, 56, 63  ; Row 7
          DB 8, 16, 24, 32, 40, 48, 56, 7, 72   ; Row 8 (8*7=56, 这里是7, ERROR)
          DB 9, 18, 27, 36, 45, 54, 63, 72, 81  ; Row 9

    MSG_ERR DB ' error', 0DH, 0AH, '$'
    SPACE   DB ' ', '$'
DATA ENDS

CODE SEGMENT
    ASSUME CS:CODE, DS:DATA
START:
    MOV AX, DATA
    MOV DS, AX

    MOV SI, 0       ; SI 用于遍历 TABLE 数组的偏移量
    MOV CX, 1       ; CX = 当前行号 (Row: 1-9)

ROW_LOOP:
    MOV BX, 1       ; BX = 当前列号 (Col: 1-9)

COL_LOOP:
    ; --- 1. 计算理论正确值 ---
    MOV AX, CX      ; 被乘数放 AX (实际只有 AL 有效)
    MUL BL          ; 乘法: AL * BL -> AX (乘积在 AL 中，因为结果<81)

    ; --- 2. 获取内存实际值 ---
    MOV DL, TABLE[SI] ; 从内存取数

    ; --- 3. 比较 ---
    CMP AL, DL
    JE  NEXT_ITEM   ; 如果相等(ZF=1)，跳转处理下一个

    ; --- 4. 发现错误，调用子过程 ---
    ; 关键点：保存主程序环境！因为子过程可能会修改寄存器
    PUSH AX
    PUSH BX
    PUSH CX
    PUSH DX

    CALL PRINT_ERROR_MSG ; 调用打印子程序

    ; 恢复环境
    POP DX
    POP CX
    POP BX
    POP AX

NEXT_ITEM:
    INC SI          ; 指向下一个数据字节
    INC BX          ; 列号+1
    CMP BX, 9
    JLE COL_LOOP    ; 内循环判断

    INC CX          ; 行号+1
    CMP CX, 9
    JLE ROW_LOOP    ; 外循环判断

    ; 退出程序
    MOV AH, 4CH
    INT 21H

; =============================================
; 子过程：PRINT_ERROR_MSG
; 功能：显示格式为 "行 列 error"
; 入口参数：CX = 行号, BX = 列号
; =============================================
PRINT_ERROR_MSG PROC NEAR
    ; 打印行号 (Row)
    MOV AX, CX
    CALL PRINT_DIGIT

    ; 打印空格
    MOV AH, 09H
    LEA DX, SPACE
    INT 21H

    ; 打印列号 (Col)
    MOV AX, BX
    CALL PRINT_DIGIT

    ; 打印错误提示
    MOV AH, 09H
    LEA DX, MSG_ERR
    INT 21H

    RET
PRINT_ERROR_MSG ENDP

; 辅助子过程：打印个位数字
PRINT_DIGIT PROC NEAR
    PUSH DX         ; 保护 DX
    ADD AL, 30H     ; 将数字转换为 ASCII 码
    MOV DL, AL
    MOV AH, 02H     ; DOS 2号功能调用：显示字符
    INT 21H
    POP DX          ; 恢复 DX
    RET
PRINT_DIGIT ENDP

CODE ENDS
    END START
```

## 四、 C 语言对比分析（反汇编观察）

实验要求利用 C 语言分别将数组定义为**全局变量**和**局部变量**，观察反汇编代码的区别。

### 1. 全局变量 (Global)

- **代码定义**：在 `main` 函数外部定义 `unsigned char table[] = {...};`。
- **存储位置**：数据存储在 **数据段 (.data)** 中。
- **汇编行为**：
  - 在程序编译时，数据已经被硬编码在可执行文件的特定段中。
  - 访问时，CPU 使用绝对地址（或 RIP 相对寻址）直接读取内存。
  - 例如：`MOV EAX, DWORD PTR [table_global + offset]`。
- **优点**：无需运行时初始化，访问速度快。

### 2. 局部变量 (Local)

- **代码定义**：在 `main` 函数内部定义 `unsigned char table[] = {...};`。
- **存储位置**：数据存储在 **栈 (Stack)** 中。
- **汇编行为**：
  - 在函数被调用时，编译器会生成大量指令来初始化栈空间。
  - 正如 C 语言截图所示，会看到大量的 `MOV [RBP-XX], value` 指令。这是程序在运行时一条条把数据“搬运”到栈上的过程。
  - 访问时，基于栈基指针（RBP/EBP）进行偏移访问。
- **区别总结**：局部数组的大量初始化赋值会显著增加函数开头的指令数量和执行时间，且占用栈空间。

## 五、 实验结果

运行编译后的汇编程序 (`HW4-2.EXE`)，控制台输出如下：

```text
1 1 error
2 3 error
4 4 error
6 5 error
8 7 error
```

**结果验证**：

1.  **Row 1, Col 1**: 理论值 1 (`1*1`)，内存值 7。 **(检测正确)**
2.  **Row 2, Col 3**: 理论值 6 (`2*3`)，内存值 7。 **(检测正确)**
3.  **Row 4, Col 4**: 理论值 16 (`4*4`)，内存值 7。 **(检测正确)**
4.  **Row 6, Col 5**: 理论值 30 (`6*5`)，内存值 7。 **(检测正确)**
5.  **Row 8, Col 7**: 理论值 56 (`8*7`)，内存值 7。 **(检测正确)**

程序成功识别了所有预置的错误数据并正确输出了坐标。

## 六、 实验总结与体会

1.  **过程调用与资源保护**：
    在编写 `PRINT_ERROR_MSG` 子过程时，深刻体会到了**保护现场**的重要性。主程序利用 `CX` 和 `BX` 控制循环，而 DOS 中断调用（`INT 21H`）或子过程内部可能会复用这些寄存器（如 `AX` 用于传参，`DX` 用于地址）。如果在调用前不使用 `PUSH` 保存，调用后不使用 `POP` 恢复，主循环的逻辑就会崩溃（例如死循环或跳出）。

2.  **乘法指令 MUL**：
    `MUL BL` 指令隐含使用了 `AL` 作为被乘数，结果存放在 `AX` 中。在处理 8 位数据时，需要注意结果是否会溢出 8 位（虽然 9\*9=81 即使在 `AL` 中也能放下，但在 16 位逻辑中结果始终在 `AX`）。

3.  **寻址方式的灵活运用**：
    使用了 `TABLE[SI]` 这种形式（基址变址或直接变址），配合 `INC SI`，非常高效地将二维的矩阵概念（行、列）映射到了一维的线性内存模型中。

4.  **高级语言与汇编的联系**：
    通过 C 语言反汇编的对比，直观理解了“栈”和“数据段”的区别。在汇编层面，全局变量只是一个内存地址标签，而局部变量的初始化则是由一条条机器指令动态完成的，这让我对高级语言的“初始化代价”有了直观认识。
