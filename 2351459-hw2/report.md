# 2：按要求打印 ASCII 表

**姓名**：[滕其峰]

**学号**：[2351459]

**日期**：2025/12/7

---

## 一、 实验背景与目的

1.  **熟悉 ASCII 码表**：掌握常用字符（特别是小写字母 'a'-'z'）的 ASCII 编码范围（97-122）。
2.  **掌握循环控制指令**：深入理解 `LOOP` 指令的执行机制，特别是双重循环中 `CX` 寄存器的管理与堆栈保护（`PUSH`/`POP`）。
3.  **掌握条件跳转指令**：学会使用 `CMP` 配合 `JNE`、`JBE` 等跳转指令构造逻辑循环，不依赖 `CX` 计数器。
4.  **理解 DOS 系统调用**：熟练使用 `INT 21H` 的 02H（单字符输出）和 09H（字符串输出）功能，并理解中断调用对寄存器的影响。

## 二、 实验要求

输出 ASCII 表中的小写字母部分（'a' 到 'z'），要求格式如下：

- 每行打印 13 个字符。
- 共打印 2 行（26 个字母 / 13 = 2 行）。
- 分别使用 `LOOP` 指令和条件跳转指令实现。
- 用 C 语言实现并在反汇编层面进行对比分析。

## 三、 实验原理与代码实现

### 方法一：使用 LOOP 指令实现 (双重循环)

**原理分析**：

- **外层循环**：控制行数。共 2 行，`CX` 初始化为 2。
- **内层循环**：控制每行的字符数。每行 13 个，`CX` 初始化为 13。
- **难点处理**：
  1.  **CX 冲突**：`LOOP` 指令默认使用 `CX` 寄存器递减。在双重循环中，内层循环会覆盖外层循环的 `CX` 值。因此，在进入内层循环前必须 `PUSH CX` 保存外层计数，内层结束后 `POP CX` 恢复。
  2.  **寄存器污染**：打印换行符使用 `INT 21H (AH=09H)`，该指令要求 `DX` 指向字符串地址。这会覆盖 `DL` 中正在保存的当前字符。因此在打印换行前，必须 `PUSH DX` 保护当前字符，打印后 `POP DX` 恢复。

**代码实现 (`loop.asm`)**：

```assembly
DATA SEGMENT
    CRLF DB 0DH, 0AH, '$'   ; 回车换行符
DATA ENDS

CODE SEGMENT
    ASSUME CS:CODE, DS:DATA

MAIN:
    MOV AX, DATA
    MOV DS, AX

    MOV DL, 'a'         ; 初始化打印字符，从 'a' 开始
    MOV CX, 2           ; 外层循环计数：2行

OUTER_LOOP:
    PUSH CX             ; 【关键】保护外层循环次数
    MOV CX, 13          ; 内层循环计数：13个字符

INNER_LOOP:
    MOV AH, 02H         ; DOS功能调用：打印DL中的字符
    INT 21H
    INC DL              ; 字符递增
    LOOP INNER_LOOP     ; 内层循环：CX--，若CX!=0则跳转

    ; --- 换行处理 ---
    PUSH DX             ; 【关键】保护DL中的当前字符，因为09H调用会修改DX

    LEA DX, CRLF        ; 装载回车换行符地址到DX
    MOV AH, 09H         ; DOS功能调用：打印字符串
    INT 21H

    POP DX              ; 恢复DL中的字符

    POP CX              ; 【关键】恢复外层循环次数
    LOOP OUTER_LOOP     ; 外层循环：CX--

    MOV AH, 4CH         ; 退出程序
    INT 21H

CODE ENDS
END MAIN
```

### 方法二：使用条件跳转指令实现

**原理分析**：

- 不再依赖 `CX` 进行自动计数，而是使用通用寄存器（如 `BL`）作为计数器。
- **逻辑流程**：
  1.  打印字符，字符加 1。
  2.  计数器 `BL` 加 1。
  3.  使用 `CMP BL, 13` 检测是否到达行末。如果不相等 (`JNE`) 则继续，相等则打印换行并清零计数器。
  4.  使用 `CMP DL, 'z'` 检测是否已打印完最后一个字符。如果小于等于 (`JBE`) 'z'，则跳回继续执行。

**代码实现 (`jmp.asm`)**：

```assembly
DATA SEGMENT
    CRLF DB 0DH, 0AH, '$'
DATA ENDS

CODE SEGMENT
    ASSUME CS:CODE, DS:DATA

MAIN:
    MOV AX, DATA
    MOV DS, AX

    MOV DL, 'a'         ; 当前字符
    MOV BL, 0           ; 行内计数器 (0-13)

PRINT_LOOP:
    MOV AH, 02H
    INT 21H             ; 打印字符
    INC DL              ; 下一个字符
    INC BL              ; 计数器+1

    CMP BL, 13          ; 判断是否满13个
    JNE CONTINUE_LOOP   ; 未满则跳过换行逻辑

    ; --- 换行逻辑 ---
    PUSH DX             ; 保护当前字符
    LEA DX, CRLF
    MOV AH, 09H
    INT 21H
    POP DX              ; 恢复当前字符
    MOV BL, 0           ; 重置行内计数器

CONTINUE_LOOP:
    CMP DL, 'z'         ; 判断是否超过 'z'
    JBE PRINT_LOOP      ; 若 DL <= 'z'，继续循环

    MOV AH, 4CH
    INT 21H

CODE ENDS
END MAIN
```

---

## 四、 C 语言反汇编对比分析

为了理解编译器如何处理同样的逻辑，我们编写 C 语言代码并观察其底层实现。

**1. C 语言代码示例**

```c
#include <stdio.h>

int main() {
    char c = 'a';
    int count = 0;

    // 对应汇编中的条件跳转逻辑
    while (c <= 'z') {
        printf("%c", c);
        count++;
        c++;

        if (count == 13) {
            printf("\n");
            count = 0;
        }
    }
    return 0;
}
```

**2. 反汇编分析 (Intel 语法)**

在 C 语言的反汇编代码中，我们通常能观察到以下现象：

1.  **变量存储**：
    - 局部变量 `c` 和 `count` 通常存储在栈帧中 (例如 `[rbp-4]`, `[rbp-8]`)，而不是像手写汇编那样一直保留在寄存器 (`DL`, `BL`) 中。编译器会频繁生成 `MOV` 指令在寄存器和内存之间搬运数据。
2.  **循环与跳转**：
    - C 语言的 `while (c <= 'z')` 会被编译为 `CMP` 指令配合 `JG` (Jump if Greater) 跳出循环，或者 `JLE` (Jump if Less or Equal) 继续循环。这与我们在 `jmp.asm` 中写的 `CMP DL, 'z'` / `JBE PRINT_LOOP` 逻辑本质相同。
3.  **函数调用**：
    - C 语言的 `printf` 会被翻译为 `CALL` 指令。在调用前，编译器会将参数压栈或放入特定寄存器（取决于调用约定）。而在手写汇编中，我们直接使用了 DOS 中断 `INT 21H`。

**结论**：
手写汇编（方法二）的逻辑更接近 C 语言的底层执行流。相比之下，方法一使用的 `LOOP` 指令是 x86 架构特有的硬件循环优化，C 编译器通常更倾向于使用通用的 `CMP/JMP` 组合而不是生成 `LOOP` 指令，因为 `CMP/JMP` 在现代流水线处理器上往往有更好的预测性能。

## 六、 实验总结

通过本次实验，我深刻理解了以下几点：

1.  **堆栈的重要性**：在双重循环中，`CX` 寄存器是临界资源。如果不进行压栈保护，内层循环结束后 `CX` 变为 0，导致外层循环失效或死循环。这是汇编编程与高级语言编程最大的不同点之一——必须手动管理上下文。
2.  **中断对环境的影响**：在使用 DOS 中断（如 `INT 21H`）时，必须查阅文档明确其输入参数和会修改的寄存器。在本例中，如果不保护 `DX`，打印换行符的操作就会破坏主逻辑中的字符计数。
3.  **灵活的控制流**：`LOOP` 指令适合次数固定的循环，代码简洁；而 `CMP` + 跳转指令更加灵活，适合处理复杂的终止条件（如本例中的 `CMP DL, 'z'`）。

---
